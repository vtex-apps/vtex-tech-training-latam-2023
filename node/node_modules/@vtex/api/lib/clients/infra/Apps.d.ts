/// <reference types="node" />
import { IncomingMessage } from 'http';
import { Readable, Writable } from 'stream';
import { ZlibOptions } from 'zlib';
import { InstanceOptions } from '../../HttpClient';
import { AppBundleLinked, AppFilesList, AppManifest } from '../../responses';
import { IOContext } from '../../service/worker/runtime/typings';
import { InfraClient } from './InfraClient';
export declare class Apps extends InfraClient {
    private _routes;
    private diskCache;
    private memoryCache;
    private get routes();
    constructor(context: IOContext, options?: InstanceOptions);
    installApp: (descriptor: string) => Promise<void> | Promise<AppInstallResponse>;
    uninstallApp: (app: string) => Promise<import("../..").IOResponse<void>>;
    acknowledgeApp: (app: string, service: string) => Promise<void>;
    link: (app: string, files: Change[], { zlib }?: ZipOptions) => Promise<AppBundleLinked>;
    patch: (app: string, changes: Change[], { zlib }?: ZipOptions) => Promise<void>;
    unlink: (app: string) => Promise<import("../..").IOResponse<void>>;
    unlinkAll: () => Promise<import("../..").IOResponse<void>>;
    saveAppSettings: (app: string, settings: any) => Promise<void>;
    listApps: ({ oldVersion, since, service }?: ListAppsOptions) => Promise<AppsList>;
    listAppFiles: (app: string, { prefix, nextMarker }?: ListFilesOptions) => Promise<AppFilesList>;
    listLinks: () => Promise<string[]>;
    getAppFile: (app: string, path: string, staleIfError?: boolean | undefined) => Promise<{
        data: Buffer;
        headers: any;
    }>;
    getAppJSON: <T extends object | null>(app: string, path: string, nullIfNotFound?: boolean | undefined) => Promise<T>;
    getFileFromApps: <T extends object | null>(app: string, path: string, nullIfNotFound?: boolean | undefined) => Promise<T>;
    getAppFileStream: (app: string, path: string) => Promise<IncomingMessage>;
    getApp: (app: string) => Promise<AppManifest>;
    getAppSettings: (app: string) => Promise<any>;
    getAllAppsSettings: (listAppsOptions?: ListAppsOptions) => Promise<AppsSettings>;
    getAppBundle: (app: string, bundlePath: string, generatePackageJson: boolean) => Promise<Readable>;
    unpackAppBundle: (app: string, bundlePath: string, unpackPath: string, generatePackageJson: boolean) => Promise<Writable>;
    getAppsMetaInfos: (filter?: string | undefined, staleWhileRevalidate?: boolean) => Promise<AppMetaInfo[]>;
    getDependencies: (filter?: string) => Promise<Record<string, string[]>>;
    updateDependencies: () => Promise<Record<string, string[]>>;
    updateDependency: (name: string, version: string, registry: string) => Promise<void>;
    resolveDependencies: (apps: string[], registries: string[], filter?: string) => Promise<any>;
    resolveDependenciesWithManifest: (manifest: AppManifest, filter?: string) => Promise<Record<string, string[]>>;
    private installRuntime;
}
interface ZipOptions {
    zlib?: ZlibOptions;
}
export interface AppMetaInfo {
    id: string;
    settingsSchema?: Record<string, any>;
    _resolvedDependencies: Record<string, string>;
    _isRoot: boolean;
    _buildFeatures: Record<string, string[]>;
}
export interface WorkspaceMetaInfo {
    apps: AppMetaInfo[];
}
export interface AppsListItem {
    app: string;
    id: string;
    location: string;
}
export interface AppsList {
    data: AppsListItem[];
}
export interface Change {
    path: string;
    content: string | Readable | Buffer;
}
export interface ListAppsOptions {
    oldVersion?: string;
    context?: string[];
    since?: string;
    service?: string;
}
export interface ListFilesOptions {
    prefix?: string;
    context?: string[];
    nextMarker?: string;
}
export interface AppsSettings {
    [app: string]: any;
}
export interface AppInstallResponse {
    message: string;
}
export {};
