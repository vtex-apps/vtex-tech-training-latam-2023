/// <reference types="node" />
import { IncomingMessage } from 'http';
import { Readable } from 'stream';
import { InstanceOptions } from '../../HttpClient';
import { BucketMetadata, FileListItem } from '../../responses';
import { IOContext } from '../../service/worker/runtime/typings';
import { InfraClient } from './InfraClient';
export declare class VBase extends InfraClient {
    constructor(context: IOContext, options?: InstanceOptions);
    getBucket: (bucket: string) => Promise<BucketMetadata>;
    resetBucket: (bucket: string) => Promise<import("../../HttpClient").IOResponse<void>>;
    listFiles: (bucket: string, opts?: string | VBaseOptions | undefined) => Promise<BucketFileList>;
    getFile: (bucket: string, path: string) => Promise<{
        data: Buffer;
        headers: any;
    }>;
    getJSON: <T>(bucket: string, path: string, nullIfNotFound?: boolean | undefined, conflictsResolver?: ConflictsResolver<T> | undefined) => Promise<T>;
    getFileStream: (bucket: string, path: string) => Promise<IncomingMessage>;
    saveFile: (bucket: string, path: string, stream: Readable, gzip?: boolean, ttl?: number | undefined) => Promise<void>;
    getFileMetadata: (bucket: string, path: string) => Promise<import("../../HttpClient").IOResponse<void>>;
    saveJSON: <T>(bucket: string, path: string, data: T) => Promise<void>;
    saveZippedContent: (bucket: string, path: string, stream: Readable) => Promise<void>;
    deleteFile: (bucket: string, path: string) => Promise<import("../../HttpClient").IOResponse<void>>;
    getConflicts: <T>(bucket: string) => Promise<T>;
    resolveConflict: <T>(bucket: string, path: string, content: any) => Promise<T>;
    private saveContent;
}
export interface BucketFileList {
    data: FileListItem[];
    next: string;
    smartCacheHeaders: any;
}
export interface VBaseOptions {
    prefix?: string;
    next?: string;
    limit?: number;
}
export interface VBaseSaveOptions {
    gzip?: boolean;
    unzip?: boolean;
    ttl?: number;
}
export interface VBaseConflictData {
    path: string;
    base: VBaseConflict;
    master: VBaseConflict;
    mine: VBaseConflict;
}
export interface VBaseConflict {
    contentOmitted: boolean;
    deleted: boolean;
    mimeType: string;
    parsedContent?: any;
    content: string;
}
export interface ConflictsResolver<T> {
    resolve: () => T | Promise<T>;
}
